<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>DOM 模型概述 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="foundation.css" tppabs="http://javascript.ruanyifeng.com/css/foundation.css">
  <link rel="stylesheet" href="main.css" tppabs="http://javascript.ruanyifeng.com/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="html5.js" tppabs="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="jquery.js" tppabs="http://javascript.ruanyifeng.com/js/jquery.js"></script>
  <script src="toc.js" tppabs="http://javascript.ruanyifeng.com/js/toc.js"></script>
  <script src="main.js" tppabs="http://javascript.ruanyifeng.com/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="index.htm" tppabs="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="index.htm#introduction" tppabs="http://javascript.ruanyifeng.com/#introduction">导论</a></li>
			
			<li><a href="index.htm#grammar" tppabs="http://javascript.ruanyifeng.com/#grammar">语法</a></li>
			
			<li><a href="index.htm#stdlib" tppabs="http://javascript.ruanyifeng.com/#stdlib">标准库</a></li>
			
			<li><a href="index.htm#oop" tppabs="http://javascript.ruanyifeng.com/#oop">面向对象编程</a></li>
			
			<li><a href="index.htm#advanced" tppabs="http://javascript.ruanyifeng.com/#advanced">语法专题</a></li>
			
			<li><a href="index.htm#dom" tppabs="http://javascript.ruanyifeng.com/#dom">DOM模型</a></li>
			
			<li><a href="index.htm#bom" tppabs="http://javascript.ruanyifeng.com/#bom">浏览器环境</a></li>
			
			<li><a href="index.htm#htmlapi" tppabs="http://javascript.ruanyifeng.com/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> DOM模型 </a><ul class="dropdown">















<li><a href="attribute.html" tppabs="http://javascript.ruanyifeng.com/dom/attribute.html">属性的操作</a></li>





































<li><a href="css.html" tppabs="http://javascript.ruanyifeng.com/dom/css.html">CSS操作</a></li>



















<li><a href="document.html" tppabs="http://javascript.ruanyifeng.com/dom/document.html">document节点</a></li>







<li><a href="element.html" tppabs="http://javascript.ruanyifeng.com/dom/element.html">Element对象</a></li>











<li><a href="event-type.html" tppabs="http://javascript.ruanyifeng.com/dom/event-type.html">事件种类</a></li>





<li><a href="event.html" tppabs="http://javascript.ruanyifeng.com/dom/event.html">事件模型</a></li>

































<li><a href="image.html" tppabs="http://javascript.ruanyifeng.com/dom/image.html">Image对象</a></li>



































<li><a href="mutationobserver.html" tppabs="http://javascript.ruanyifeng.com/dom/mutationobserver.html">Mutation Observer API</a></li>







<li class="active"><a href="#">DOM 模型概述</a></li>















































































<li><a href="text.html" tppabs="http://javascript.ruanyifeng.com/dom/text.html">Text节点和DocumentFragment节点</a></li>













































</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> DOM 模型概述</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="javascript:if(confirm('https://github.com/ruanyf/jstutorial  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='https://github.com/ruanyf/jstutorial'" tppabs="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> DOM 模型概述 </h1>

<aside class="right"><p>来自<a href="index.htm" tppabs="http://javascript.ruanyifeng.com/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<h2 id="基本概念">基本概念</h2>

<h3 id="dom">DOM</h3>

<p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>

<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。所以，DOM 可以理解成网页的编程接口。DOM 有自己的国际标准，目前的通用版本是<a href="javascript:if(confirm('http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html'" tppabs="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html">DOM 3</a>，下一代版本<a href="javascript:if(confirm('http://www.w3.org/TR/dom/  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://www.w3.org/TR/dom/'" tppabs="http://www.w3.org/TR/dom/">DOM 4</a>正在拟定中。</p>

<p>严格地说，DOM 不属于 JavaScript，但是操作 DOM 是 JavaScript 最常见的任务，而 JavaScript 也是最常用于 DOM 操作的语言。本章介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>

<h3 id="节点">节点</h3>

<p>DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>

<p>节点的类型有七种。</p>

<ul>
  <li><code class="highlighter-rouge">Document</code>：整个文档树的顶层节点</li>
  <li><code class="highlighter-rouge">DocumentType</code>：<code class="highlighter-rouge">doctype</code>标签（比如<code class="highlighter-rouge"><span class="cp">&lt;!DOCTYPE html&gt;</span></code>）</li>
  <li><code class="highlighter-rouge">Element</code>：网页的各种HTML标签（比如<code class="highlighter-rouge">&lt;body&gt;</code>、<code class="highlighter-rouge">&lt;a&gt;</code>等）</li>
  <li><code class="highlighter-rouge">Attribute</code>：网页元素的属性（比如<code class="highlighter-rouge">class="right"</code>）</li>
  <li><code class="highlighter-rouge">Text</code>：标签之间或标签包含的文本</li>
  <li><code class="highlighter-rouge">Comment</code>：注释</li>
  <li><code class="highlighter-rouge">DocumentFragment</code>：文档的片段</li>
</ul>

<p>这七种节点都属于浏览器原生提供的节点对象的派生对象，具有一些共同的属性和方法。</p>

<h3 id="节点树">节点树</h3>

<p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是DOM。</p>

<p>最顶层的节点就是<code class="highlighter-rouge">document</code>节点，它代表了整个文档。文档里面最高一层的HTML标签，一般是<code class="highlighter-rouge"><span class="nt">&lt;html&gt;</span></code>，它构成树结构的根节点（root node），其他HTML标签节点都是它的下级。</p>

<p>除了根节点以外，其他节点对于周围的节点都存在三种关系。</p>

<ul>
  <li>父节点关系（parentNode）：直接的那个上级节点</li>
  <li>子节点关系（childNodes）：直接的下级节点</li>
  <li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>

<p>DOM提供操作接口，用来获取三种关系的节点。其中，子节点接口包括<code class="highlighter-rouge">firstChild</code>（第一个子节点）和<code class="highlighter-rouge">lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code class="highlighter-rouge">nextSibling</code>（紧邻在后的那个同级节点）和<code class="highlighter-rouge">previousSibling</code>（紧邻在前的那个同级节点）属性。</p>

<h2 id="特征相关的属性">特征相关的属性</h2>

<p>所有节点对象都是浏览器内置的<code class="highlighter-rouge">Node</code>对象的实例，继承了<code class="highlighter-rouge">Node</code>属性和方法。这是所有节点的共同特征。</p>

<p>以下属性与节点对象本身的特征相关。</p>

<h3 id="nodenodenamenodenodetype">Node.nodeName，Node.nodeType</h3>

<p><code class="highlighter-rouge">nodeName</code>属性返回节点的名称，<code class="highlighter-rouge">nodeType</code>属性返回节点类型的常数值。具体的返回值，可查阅下方的表格。</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>nodeName</th>
      <th>nodeType</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ELEMENT_NODE</td>
      <td>大写的HTML元素名</td>
      <td>1</td>
    </tr>
    <tr>
      <td>ATTRIBUTE_NODE</td>
      <td>等同于Attr.name</td>
      <td>2</td>
    </tr>
    <tr>
      <td>TEXT_NODE</td>
      <td>#text</td>
      <td>3</td>
    </tr>
    <tr>
      <td>COMMENT_NODE</td>
      <td>#comment</td>
      <td>8</td>
    </tr>
    <tr>
      <td>DOCUMENT_NODE</td>
      <td>#document</td>
      <td>9</td>
    </tr>
    <tr>
      <td>DOCUMENT_FRAGMENT_NODE</td>
      <td>#document-fragment</td>
      <td>11</td>
    </tr>
    <tr>
      <td>DOCUMENT_TYPE_NODE</td>
      <td>等同于DocumentType.name</td>
      <td>10</td>
    </tr>
  </tbody>
</table>

<p>以<code class="highlighter-rouge">document</code>节点为例，它的<code class="highlighter-rouge">nodeName</code>属性等于<code class="highlighter-rouge">#document</code>，<code class="highlighter-rouge">nodeType</code>属性等于9。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "#document"</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="c1">// 9</span>
</code></pre></div></div>

<p>如果是一个<code class="highlighter-rouge">&lt;p&gt;</code>节点，它的<code class="highlighter-rouge">nodeName</code>是<code class="highlighter-rouge">P</code>，<code class="highlighter-rouge">nodeType</code>是1。文本节点的<code class="highlighter-rouge">nodeName</code>是<code class="highlighter-rouge">#text</code>，<code class="highlighter-rouge">nodeType</code>是3。</p>

<p>通常来说，使用<code class="highlighter-rouge">nodeType</code>属性确定一个节点的类型，比较方便。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'a'</span><span class="p">).</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="mi">1</span>
<span class="c1">// true</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'a'</span><span class="p">).</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">ELEMENT_NODE</span>
<span class="c1">// true</span>
</code></pre></div></div>

<p>上面两种写法是等价的。</p>

<h3 id="nodenodevalue">Node.nodeValue</h3>

<p><code class="highlighter-rouge">Node.nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>

<p>由于只有Text节点、Comment节点、XML文档的CDATA节点有文本值，因此只有这三类节点的<code class="highlighter-rouge">nodeValue</code>可以返回结果，其他类型的节点一律返回<code class="highlighter-rouge">null</code>。同样的，也只有这三类节点可以设置<code class="highlighter-rouge">nodeValue</code>属性的值。对于那些返回<code class="highlighter-rouge">null</code>的节点，设置<code class="highlighter-rouge">nodeValue</code>属性是无效的。</p>

<h3 id="nodetextcontent">Node.textContent</h3>

<p><code class="highlighter-rouge">Node.textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML代码为</span>
<span class="c1">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'divA'</span><span class="p">).</span><span class="nx">textContent</span>
<span class="c1">// This is some text</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">textContent</code>属性自动忽略当前节点内部的HTML标签，返回所有文本内容。</p>

<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对HTML标签转义。这很适合用于用户提供的内容。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">).</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">'&lt;p&gt;GoodBye!&lt;/p&gt;'</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码在插入文本时，会将<code class="highlighter-rouge">&lt;p&gt;</code>标签解释为文本，而不会当作标签处理。</p>

<p>对于Text节点和Comment节点，该属性的值与<code class="highlighter-rouge">nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括Comment节点。如果一个节点没有子节点，则返回空字符串。</p>

<p><code class="highlighter-rouge">document</code>节点和<code class="highlighter-rouge">doctype</code>节点的<code class="highlighter-rouge">textContent</code>属性为<code class="highlighter-rouge">null</code>。如果要读取整个文档的内容，可以使用<code class="highlighter-rouge">document.documentElement.textContent</code>。</p>

<h3 id="nodebaseuri">Node.baseURI</h3>

<p><code class="highlighter-rouge">Node.baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。如果无法取到这个值，则返回<code class="highlighter-rouge">null</code>。浏览器根据这个属性，计算网页上的相对路径的URL。该属性为只读。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当前网页的网址为</span>
<span class="c1">// http://www.example.com/index.html</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">baseURI</span>
<span class="c1">// "http://www.example.com/index.html"</span>
</code></pre></div></div>

<p>不同节点都可以调用这个属性（比如<code class="highlighter-rouge">document.baseURI</code>和<code class="highlighter-rouge">element.baseURI</code>），通常它们的值是相同的。</p>

<p>该属性的值一般由当前网址的URL（即<code class="highlighter-rouge">window.location</code>属性）决定，但是可以使用HTML的<code class="highlighter-rouge">&lt;base&gt;</code>标签，改变该属性的值。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;base</span> <span class="na">href=</span><span class="s">"http://www.example.com/page.html"</span><span class="nt">&gt;</span>
<span class="nt">&lt;base</span> <span class="na">target=</span><span class="s">"_blank"</span> <span class="na">href=</span><span class="s">"http://www.example.com/page.html"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>设置了以后，<code class="highlighter-rouge">baseURI</code>属性就返回<code class="highlighter-rouge">&lt;base&gt;</code>标签设置的值。</p>

<h2 id="相关节点的属性">相关节点的属性</h2>

<p>以下属性返回当前节点的相关节点。</p>

<h3 id="nodeownerdocument">Node.ownerDocument</h3>

<p><code class="highlighter-rouge">Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code class="highlighter-rouge">document</code>对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">;</span>
<span class="nx">d</span> <span class="o">===</span> <span class="nb">document</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">document</code>对象本身的<code class="highlighter-rouge">ownerDocument</code>属性，返回<code class="highlighter-rouge">null</code>。</p>

<h3 id="nodenextsibling">Node.nextSibling</h3>

<p><code class="highlighter-rouge">Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code class="highlighter-rouge">null</code>。注意，该属性还包括文本节点和评论节点。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'div-01'</span><span class="p">).</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s1">'. '</span> <span class="o">+</span> <span class="nx">el</span><span class="p">.</span><span class="nx">nodeName</span><span class="p">);</span>
  <span class="nx">el</span> <span class="o">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">;</span>
  <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码遍历<code class="highlighter-rouge">div-01</code>节点的所有子节点。</p>

<p>下面两个表达式指向同一个节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nextSibling</span>
</code></pre></div></div>

<h3 id="nodeprevioussibling">Node.previousSibling</h3>

<p><code class="highlighter-rouge">previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// html 代码如下</span>
<span class="c1">// &lt;a&gt;&lt;span id="b1"&gt;&lt;/span&gt;&lt;span id="b2"&gt;&lt;/span&gt;&lt;/a&gt;</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'b1'</span><span class="p">).</span><span class="nx">previousSibling</span> <span class="c1">// null</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'b2'</span><span class="p">).</span><span class="nx">previousSibling</span><span class="p">.</span><span class="nx">id</span> <span class="c1">// "b1"</span>
</code></pre></div></div>

<p>对于当前节点前面有空格，则<code class="highlighter-rouge">previousSibling</code>属性会返回一个内容为空格的文本节点。</p>

<h3 id="nodeparentnode">Node.parentNode</h3>

<p><code class="highlighter-rouge">parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：<code class="highlighter-rouge">element</code>节点、<code class="highlighter-rouge">document</code>节点和<code class="highlighter-rouge">documentfragment</code>节点。</p>

<p>下面代码是如何从父节点移除指定节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于document节点和documentfragment节点，它们的父节点都是null。另外，对于那些生成后还没插入DOM树的节点，父节点也是null。</p>

<h3 id="nodeparentelement">Node.parentElement</h3>

<p>parentElement属性返回当前节点的父Element节点。如果当前节点没有父节点，或者父节点类型不是Element节点，则返回null。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码设置指定节点的父Element节点的CSS属性。</p>

<p>在IE浏览器中，只有Element节点才有该属性，其他浏览器则是所有类型的节点都有该属性。</p>

<h3 id="nodechildnodes">Node.childNodes</h3>

<p>childNodes属性返回一个NodeList集合，成员包括当前节点的所有子节点。注意，除了HTML元素节点，该属性返回的还包括Text节点和Comment节点。如果当前节点不包括任何子节点，则返回一个空的NodeList集合。由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">ulElementChildNodes</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'ul'</span><span class="p">).</span><span class="nx">childNodes</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="nodefirstchildnodelastchild">Node.firstChild，Node.lastChild</h3>

<p><code class="highlighter-rouge">firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code class="highlighter-rouge">null</code>（注意，不是<code class="highlighter-rouge">undefined</code>）。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"para-01"</span><span class="nt">&gt;&lt;span&gt;</span>First span<span class="nt">&lt;/span&gt;&lt;/p&gt;</span>

<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'para-01'</span><span class="p">).</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeName</span>
  <span class="p">)</span> <span class="c1">// "SPAN"</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">p</code>元素的第一个子节点是<code class="highlighter-rouge">span</code>元素。</p>

<p>注意，<code class="highlighter-rouge">firstChild</code>返回的除了HTML元素子节点，还可能是文本节点或评论节点。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"para-01"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;span&gt;</span>First span<span class="nt">&lt;/span&gt;</span>
<span class="nt">&lt;/p&gt;</span>

<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'para-01'</span><span class="p">).</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeName</span>
  <span class="p">)</span> <span class="c1">// "#text"</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">p</code>元素与<code class="highlighter-rouge">span</code>元素之间有空白字符，这导致<code class="highlighter-rouge">firstChild</code>返回的是文本节点。</p>

<p><code class="highlighter-rouge">Node.lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。</p>

<h2 id="节点对象的方法">节点对象的方法</h2>

<h3 id="nodeappendchild">Node.appendChild()</h3>

<p><code class="highlighter-rouge">Node.appendChild</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div></div>

<p>如果参数节点是DOM中已经存在的节点，<code class="highlighter-rouge">appendChild</code>方法会将其从原来的位置，移动到新位置。</p>

<h3 id="nodehaschildnodes">Node.hasChildNodes()</h3>

<p><code class="highlighter-rouge">Node.hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">hasChildNodes</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码表示，如果foo节点有子节点，就移除第一个子节点。</p>

<p><code class="highlighter-rouge">hasChildNodes</code>方法结合<code class="highlighter-rouge">firstChild</code>属性和<code class="highlighter-rouge">nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">DOMComb</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">hasChildNodes</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span> <span class="nx">node</span><span class="p">;</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">DOMComb</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">callback</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码的<code class="highlighter-rouge">DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printContent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">DOMComb</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> <span class="nx">printContent</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="nodeclonenode">Node.cloneNode()</h3>

<p><code class="highlighter-rouge">Node.cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是<code class="highlighter-rouge">false</code>，即不克隆子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cloneUL</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'ul'</span><span class="p">).</span><span class="nx">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div></div>

<p>需要注意的是，克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code class="highlighter-rouge">addEventListener</code>方法和<code class="highlighter-rouge">on-</code>属性（即<code class="highlighter-rouge">node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>

<p>克隆一个节点之后，DOM树有可能出现两个有相同ID属性（即<code class="highlighter-rouge">id="xxx"</code>）的HTML元素，这时应该修改其中一个HTML元素的ID属性。</p>

<h3 id="nodeinsertbefore">Node.insertBefore()</h3>

<p><code class="highlighter-rouge">insertBefore</code>方法用于将某个节点插入当前节点内部的指定位置。它接受两个参数，第一个参数是所要插入的节点，第二个参数是当前节点内部的一个子节点，新的节点将插在这个子节点的前面。该方法返回被插入的新节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">'1'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">li</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'li'</span><span class="p">);</span>
<span class="nx">li</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">text1</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">ul</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'ul'</span><span class="p">);</span>
<span class="nx">ul</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">li</span><span class="p">,</span> <span class="nx">ul</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码使用当前节点的<code class="highlighter-rouge">firstChild</code>属性，在<code class="highlighter-rouge">&lt;ul&gt;</code>节点的最前面插入一个新建的<code class="highlighter-rouge">&lt;li&gt;</code>节点，新节点变成第一个子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parentElement</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">newElement</span><span class="p">,</span> <span class="nx">parentElement</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，如果当前节点没有任何子节点，<code class="highlighter-rouge">parentElement.firstChild</code>会返回<code class="highlighter-rouge">null</code>，则新节点会成为当前节点的唯一子节点。</p>

<p>如果<code class="highlighter-rouge">insertBefore</code>方法的第二个参数为<code class="highlighter-rouge">null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p>

<p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p>

<p>由于不存在<code class="highlighter-rouge">insertAfter</code>方法，如果要插在当前节点的某个子节点后面，可以用<code class="highlighter-rouge">insertBefore</code>方法结合<code class="highlighter-rouge">nextSibling</code>属性模拟。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parent</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">parent</code>是父节点，<code class="highlighter-rouge">s1</code>是一个全新的节点，<code class="highlighter-rouge">s2</code>是可以将<code class="highlighter-rouge">s1</code>节点，插在<code class="highlighter-rouge">s2</code>节点的后面。如果<code class="highlighter-rouge">s2</code>是当前节点的最后一个子节点，则<code class="highlighter-rouge">s2.nextSibling</code>返回<code class="highlighter-rouge">null</code>，这时<code class="highlighter-rouge">s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code class="highlighter-rouge">s2</code>的后面。</p>

<h3 id="noderemovechild">Node.removeChild()</h3>

<p><code class="highlighter-rouge">Node.removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。它返回被移除的子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'A'</span><span class="p">);</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码是如何移除一个指定节点。</p>

<p>注意，这个方法是在父节点上调用的，不是在被移除的节点上调用的。</p>

<p>下面是如何移除当前节点的所有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'top'</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>被移除的节点依然存在于内存之中，但不再是DOM的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>

<h3 id="nodereplacechild">Node.replaceChild()</h3>

<p><code class="highlighter-rouge">Node.replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">replacedNode</span> <span class="o">=</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nx">replaceChild</span><span class="p">(</span><span class="nx">newChild</span><span class="p">,</span> <span class="nx">oldChild</span><span class="p">);</span>
</code></pre></div></div>

<p>下面是一个例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'A'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">newSpan</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'span'</span><span class="p">);</span>
<span class="nx">newSpan</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">'Hello World!'</span><span class="p">;</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">replaceChild</span><span class="p">(</span><span class="nx">newSpan</span><span class="p">,</span> <span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码是如何替换指定节点。</p>

<h3 id="nodecontains">Node.contains()</h3>

<p><code class="highlighter-rouge">Node.contains</code>方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span></code></pre></figure>

<p>上面代码检查某个节点，是否包含在当前文档之中。</p>

<p>注意，如果将当前节点传入contains方法，会返回true。虽然从意义上说，一个节点不应该包含自身。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nodeA</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">nodeA</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="nodecomparedocumentposition">Node.compareDocumentPosition()</h3>

<p><code class="highlighter-rouge">compareDocumentPosition</code>方法的用法，与<code class="highlighter-rouge">contains</code>方法完全一致，返回一个7个比特位的二进制值，表示参数节点与当前节点的关系。</p>

<table>
  <thead>
    <tr>
      <th>二进制值</th>
      <th>数值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>000000</td>
      <td>0</td>
      <td>两个节点相同</td>
    </tr>
    <tr>
      <td>000001</td>
      <td>1</td>
      <td>两个节点不在同一个文档（即有一个节点不在当前文档）</td>
    </tr>
    <tr>
      <td>000010</td>
      <td>2</td>
      <td>参数节点在当前节点的前面</td>
    </tr>
    <tr>
      <td>000100</td>
      <td>4</td>
      <td>参数节点在当前节点的后面</td>
    </tr>
    <tr>
      <td>001000</td>
      <td>8</td>
      <td>参数节点包含当前节点</td>
    </tr>
    <tr>
      <td>010000</td>
      <td>16</td>
      <td>当前节点包含参数节点</td>
    </tr>
    <tr>
      <td>100000</td>
      <td>32</td>
      <td>浏览器的私有用途</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML代码为</span>
<span class="c1">// &lt;div id="mydiv"&gt;</span>
<span class="c1">//   &lt;form&gt;</span>
<span class="c1">//     &lt;input id="test" /&gt;</span>
<span class="c1">//   &lt;/form&gt;</span>
<span class="c1">// &lt;/div&gt;</span>

<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'mydiv'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'test'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="c1">// 20</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">div</span><span class="p">)</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p>上面代码中，节点<code class="highlighter-rouge">div</code>包含节点<code class="highlighter-rouge">input</code>，而且节点<code class="highlighter-rouge">input</code>在节点<code class="highlighter-rouge">div</code>的后面，所以第一个<code class="highlighter-rouge">compareDocumentPosition</code>方法返回<code class="highlighter-rouge">20</code>（二进制<code class="highlighter-rouge">010100</code>），第二个<code class="highlighter-rouge">compareDocumentPosition</code>方法返回<code class="highlighter-rouge">10</code>（二进制<code class="highlighter-rouge">001010</code>）。</p>

<p>由于<code class="highlighter-rouge">compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'文档结构正确'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'&lt;body&gt; 不能在 &lt;head&gt; 前面'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">compareDocumentPosition</code>的返回值与<code class="highlighter-rouge">4</code>（又称掩码）进行与运算（<code class="highlighter-rouge">&amp;</code>），得到一个布尔值，表示<code class="highlighter-rouge">&lt;head&gt;</code>是否在<code class="highlighter-rouge">&lt;body&gt;</code>前面。</p>

<p>在这个方法的基础上，可以部署一些特定的函数，检查节点的位置。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Node</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">before</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">nodeA</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="nx">nodeB</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码在<code class="highlighter-rouge">Node</code>对象上部署了一个<code class="highlighter-rouge">before</code>方法，返回一个布尔值，表示参数节点是否在当前节点的前面。</p>

<h3 id="nodeisequalnode">Node.isEqualNode()</h3>

<p>isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">targetEl</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"targetEl"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">firstDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"div"</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>

<span class="nx">targetEl</span><span class="p">.</span><span class="nx">isEqualNode</span><span class="p">(</span><span class="nx">firstDiv</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="nodenormalize">Node.normalize()</h3>

<p>normailize方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">"div"</span><span class="p">);</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">"Part 1 "</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">"Part 2 "</span><span class="p">));</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">normalize</span><span class="p">();</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p>上面代码使用normalize方法之前，wrapper节点有两个Text子节点。使用normalize方法之后，两个Text子节点被合并成一个。</p>

<p>该方法是<code class="highlighter-rouge">Text.splitText</code>的逆方法，可以查看《Text节点》章节，了解更多内容。</p>

<h2 id="nodelist对象htmlcollection对象">NodeList对象，HTMLCollection对象</h2>

<p>节点都是单个对象，有时会需要一种数据结构，能够容纳多个节点。DOM提供两种集合对象，用于实现这种节点的集合：<code class="highlighter-rouge">NodeList</code>和<code class="highlighter-rouge">HTMLCollection</code>。</p>

<p>这两个对象都是构造函数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="nx">NodeList</span> <span class="c1">// "function"</span>
<span class="k">typeof</span> <span class="nx">HTMLCollection</span> <span class="c1">// "function"</span>
</code></pre></div></div>

<p>但是，一般不把它们当作函数使用，甚至都没有直接使用它们的场合。主要是许多DOM属性和方法，返回的结果是<code class="highlighter-rouge">NodeList</code>实例或<code class="highlighter-rouge">HTMLCollection</code>实例，所以一般只使用它们的实例。</p>

<h3 id="nodelist对象">NodeList对象</h3>

<p><code class="highlighter-rouge">NodeList</code>实例对象是一个类似数组的对象，它的成员是节点对象。<code class="highlighter-rouge">Node.childNodes</code>、<code class="highlighter-rouge">document.querySelectorAll()</code>返回的都是<code class="highlighter-rouge">NodeList</code>实例对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">childNodes</span> <span class="k">instanceof</span> <span class="nx">NodeList</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">NodeList</code>实例对象可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。<code class="highlighter-rouge">Node.childNodes</code>返回的，就是一个动态集合。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'parent'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'div'</span><span class="p">));</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 3</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">parent.childNodes</code>返回的是一个<code class="highlighter-rouge">NodeList</code>实例对象。当<code class="highlighter-rouge">parent</code>节点新增一个子节点以后，该对象的成员个数就增加了1。</p>

<p><code class="highlighter-rouge">document.querySelectorAll</code>方法返回的是一个静态集合。DOM内部的变化，并不会实时反映在该方法的返回结果之中。</p>

<p><code class="highlighter-rouge">NodeList</code>接口实例对象提供<code class="highlighter-rouge">length</code>属性和数字索引，因此可以像数组那样，使用数字索引取出每个节点，但是它本身并不是数组，不能使用<code class="highlighter-rouge">pop</code>或<code class="highlighter-rouge">push</code>之类数组特有的方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组的继承链</span>
<span class="nx">myArray</span> <span class="o">--&gt;</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">--&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">--&gt;</span> <span class="kc">null</span>

<span class="c1">// NodeList的继承链</span>
<span class="nx">myNodeList</span> <span class="o">--&gt;</span> <span class="nx">NodeList</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">--&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">--&gt;</span> <span class="kc">null</span>
</code></pre></div></div>

<p>从上面的继承链可以看到，<code class="highlighter-rouge">NodeList</code>实例对象并不继承<code class="highlighter-rouge">Array.prototype</code>，因此不具有数组的方法。如果要在<code class="highlighter-rouge">NodeList</code>实例对象使用数组方法，可以将<code class="highlighter-rouge">NodeList</code>实例转为真正的数组。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div_list</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'div'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">div_array</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">div_list</span><span class="p">);</span>
</code></pre></div></div>

<p>注意，采用上面的方法将<code class="highlighter-rouge">NodeList</code>实例转为真正的数组以后，<code class="highlighter-rouge">div_array</code>就是一个静态集合了，不再能动态反映DOM的变化。</p>

<p>另一种方法是通过<code class="highlighter-rouge">call</code>方法，间接在<code class="highlighter-rouge">NodeList</code>实例上使用数组方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">forEach</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forEach</span><span class="p">;</span>

<span class="nx">forEach</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">child</span><span class="p">){</span>
  <span class="nx">child</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s1">'#0F0'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码让数组的<code class="highlighter-rouge">forEach</code>方法在<code class="highlighter-rouge">NodeList</code>实例对象上调用。注意，Chrome浏览器在<code class="highlighter-rouge">NodeList.prototype</code>上部署了<code class="highlighter-rouge">forEach</code>方法，所以可以直接使用，但它是非标准的。</p>

<p>遍历<code class="highlighter-rouge">NodeList</code>实例对象的首选方法，是使用<code class="highlighter-rouge">for</code>循环。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">myNodeList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">myNodeList</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不要使用<code class="highlighter-rouge">for...in</code>循环去遍历<code class="highlighter-rouge">NodeList</code>实例对象，因为<code class="highlighter-rouge">for...in</code>循环会将非数字索引的<code class="highlighter-rouge">length</code>属性和下面要讲到的<code class="highlighter-rouge">item</code>方法，也遍历进去，而且不保证各个成员遍历的顺序。</p>

<p>ES6新增的<code class="highlighter-rouge">for...of</code>循环，也可以正确遍历<code class="highlighter-rouge">NodeList</code>实例对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">list</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'input[type=checkbox]'</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">item</span><span class="p">.</span><span class="nx">checked</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">NodeList</code>实例对象的<code class="highlighter-rouge">item</code>方法，接受一个数字索引作为参数，返回该索引对应的成员。如果取不到成员，或者索引不合法，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nodeItem</span> <span class="o">=</span> <span class="nx">nodeList</span><span class="p">.</span><span class="nx">item</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>

<span class="c1">// 实例</span>
<span class="kd">var</span> <span class="nx">divs</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"div"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">secondDiv</span> <span class="o">=</span> <span class="nx">divs</span><span class="p">.</span><span class="nx">item</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，由于数字索引从零开始计数，所以取出第二个成员，要使用数字索引<code class="highlighter-rouge">1</code>。</p>

<p>所有类似数组的对象，都可以使用方括号运算符取出成员，所以一般情况下，都是使用下面的写法，而不使用<code class="highlighter-rouge">item</code>方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nodeItem</span> <span class="o">=</span> <span class="nx">nodeList</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="htmlcollection对象">HTMLCollection对象</h3>

<p><code class="highlighter-rouge">HTMLCollection</code>实例对象与<code class="highlighter-rouge">NodeList</code>实例对象类似，也是节点的集合，返回一个类似数组的对象。<code class="highlighter-rouge">document.links</code>、<code class="highlighter-rouge">docuement.forms</code>、<code class="highlighter-rouge">document.images</code>等属性，返回的都是<code class="highlighter-rouge">HTMLCollection</code>实例对象。</p>

<p><code class="highlighter-rouge">HTMLCollection</code>与<code class="highlighter-rouge">NodeList</code>的区别有以下几点。</p>

<p>（1）<code class="highlighter-rouge">HTMLCollection</code>实例对象的成员只能是<code class="highlighter-rouge">Element</code>节点，<code class="highlighter-rouge">NodeList</code>实例对象的成员可以包含其他节点。</p>

<p>（2）<code class="highlighter-rouge">HTMLCollection</code>实例对象都是动态集合，节点的变化会实时反映在集合中。<code class="highlighter-rouge">NodeList</code>实例对象可以是静态集合。</p>

<p>（3）<code class="highlighter-rouge">HTMLCollection</code>实例对象可以用<code class="highlighter-rouge">id</code>属性或<code class="highlighter-rouge">name</code>属性引用节点元素，<code class="highlighter-rouge">NodeList</code>只能使用数字索引引用。</p>

<p><code class="highlighter-rouge">HTMLCollection</code>实例的<code class="highlighter-rouge">item</code>方法，可以根据成员的位置参数（从<code class="highlighter-rouge">0</code>开始），返回该成员。如果取不到成员或数字索引不合法，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">img1</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">item</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 等价于下面的写法</span>
<span class="kd">var</span> <span class="nx">img1</span> <span class="o">=</span> <span class="nx">c</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HTMLCollection</code>实例的<code class="highlighter-rouge">namedItem</code>方法根据成员的<code class="highlighter-rouge">ID</code>属性或<code class="highlighter-rouge">name</code>属性，返回该成员。如果没有对应的成员，则返回<code class="highlighter-rouge">null</code>。这个方法是<code class="highlighter-rouge">NodeList</code>实例不具有的。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML代码为</span>
<span class="c1">// &lt;form id="myForm"&gt;&lt;/form&gt;</span>
<span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">forms</span><span class="p">.</span><span class="nx">namedItem</span><span class="p">(</span><span class="s1">'myForm'</span><span class="p">);</span>
<span class="c1">// 等价于下面的写法</span>
<span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">forms</span><span class="p">[</span><span class="s1">'myForm'</span><span class="p">];</span>
</code></pre></div></div>

<p>由于<code class="highlighter-rouge">item</code>方法和<code class="highlighter-rouge">namedItem</code>方法，都可以用方括号运算符代替，所以建议一律使用方括号运算符。</p>

<h2 id="parentnode接口childnode接口">ParentNode接口，ChildNode接口</h2>

<p>不同的节点除了继承Node接口以外，还会继承其他接口。ParentNode接口用于获取当前节点的Element子节点，ChildNode接口用于处理当前节点的子节点（包含但不限于Element子节点）。</p>

<h3 id="parentnode接口">ParentNode接口</h3>

<p>ParentNode接口用于获取Element子节点。Element节点、Document节点和DocumentFragment节点，部署了ParentNode接口。凡是这三类节点，都具有以下四个属性，用于获取Element子节点。</p>

<p><strong>（1）children</strong></p>

<p>children属性返回一个动态的HTMLCollection集合，由当前节点的所有Element子节点组成。</p>

<p>下面代码遍历指定节点的所有Element子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>（2）firstElementChild</strong></p>

<p>firstElementChild属性返回当前节点的第一个Element子节点，如果不存在任何Element子节点，则返回null。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">firstElementChild</span><span class="p">.</span><span class="nx">nodeName</span>
<span class="c1">// "HTML"</span>
</code></pre></div></div>

<p>上面代码中，document节点的第一个Element子节点是&lt;HTML&gt;。</p>

<p><strong>（3）lastElementChild</strong></p>

<p>lastElementChild属性返回当前节点的最后一个Element子节点，如果不存在任何Element子节点，则返回null。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">lastElementChild</span><span class="p">.</span><span class="nx">nodeName</span>
<span class="c1">// "HTML"</span>
</code></pre></div></div>

<p>上面代码中，document节点的最后一个Element子节点是&lt;HTML&gt;。</p>

<p><strong>（4）childElementCount</strong></p>

<p>childElementCount属性返回当前节点的所有Element子节点的数目。</p>

<h3 id="childnode-接口">ChildNode 接口</h3>

<p><code class="highlighter-rouge">ChildNode</code>接口用于处理子节点（包含但不限于<code class="highlighter-rouge">Element</code>子节点）。<code class="highlighter-rouge">Element</code>节点、<code class="highlighter-rouge">DocumentType</code>节点和<code class="highlighter-rouge">CharacterData</code>接口，部署了<code class="highlighter-rouge">ChildNode</code>接口。凡是这三类节点（接口），都可以使用下面四个方法。</p>

<p><strong>（1）remove()</strong></p>

<p>remove方法用于移除当前节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nx">remove</span><span class="p">()</span>
</code></pre></div></div>

<p>上面方法在DOM中移除了<code class="highlighter-rouge">el</code>节点。注意，调用这个方法的节点，是被移除的节点本身，而不是它的父节点。</p>

<p><strong>（2）before()</strong></p>

<p>before方法用于在当前节点的前面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。</p>

<p><strong>（3）after()</strong></p>

<p>after方法用于在当前节点的后面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。</p>

<p><strong>（4）replaceWith()</strong></p>

<p>replaceWith方法使用参数指定的节点，替换当前节点。如果参数是节点对象，替换当前节点的就是该节点对象；如果参数是文本，替换当前节点的就是参数对应的文本节点。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>Louis Lazaris, <a href="javascript:if(confirm('http://coding.smashingmagazine.com/2013/10/06/inside-the-box-with-vanilla-javascript/  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://coding.smashingmagazine.com/2013/10/06/inside-the-box-with-vanilla-javascript/'" tppabs="http://coding.smashingmagazine.com/2013/10/06/inside-the-box-with-vanilla-javascript/">Thinking Inside The Box With Vanilla JavaScript</a></li>
  <li>David Walsh, <a href="javascript:if(confirm('http://davidwalsh.name/classlist  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://davidwalsh.name/classlist'" tppabs="http://davidwalsh.name/classlist">HTML5 classList API</a></li>
  <li>Derek Johnson, <a href="javascript:if(confirm('http://html5doctor.com/the-classlist-api/  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://html5doctor.com/the-classlist-api/'" tppabs="http://html5doctor.com/the-classlist-api/">The classList API</a></li>
  <li>Mozilla Developer Network, <a href="javascript:if(confirm('http://davidwalsh.name/element-dataset  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://davidwalsh.name/element-dataset'" tppabs="http://davidwalsh.name/element-dataset">element.dataset API</a></li>
  <li>David Walsh, <a href="javascript:if(confirm('http://davidwalsh.name/element-dataset  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://davidwalsh.name/element-dataset'" tppabs="http://davidwalsh.name/element-dataset">The element.dataset API</a></li>
</ul>


</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="javascript:if(confirm('http://disqus.com/?ref_noscript  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://disqus.com/?ref_noscript'" tppabs="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="javascript:if(confirm('http://disqus.com/  \n\n���ļ��޷��� Teleport Ultra ����, ��Ϊ ����һ�����·���ⲿ������Ϊ������ʼ��ַ�ĵ�ַ��  \n\n�����ڷ������ϴ���?'))window.location='http://disqus.com/'" tppabs="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="license.html" tppabs="http://javascript.ruanyifeng.com/introduction/license.html">版权声明</a> | last modified on 2014-05-18 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','analytics.js'/*tpa=http://www.google-analytics.com/analytics.js*/,'ga');

  ga('create', 'UA-43771063-1', 'http://javascript.ruanyifeng.com/dom/ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


